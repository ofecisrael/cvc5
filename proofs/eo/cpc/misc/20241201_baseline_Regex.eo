; Use is_state_in_list is recursive, epsilon moves are not optimized, trans table is recursive and not a list
; regress10 38.6
(include "../theories/Arith.eo")

; The nfa type.

(declare-type Nfa ())

;(declare-type State ())
(define State () String) ; TODO try to avoid strings

(declare-const nfa.epsilon String)
(declare-const nfa.allchar String)
(declare-const nfa.range (-> String String String))

(declare-const nfa.decline State)

; nfa.trans "s" "a" "a" (nfa.trans "s" "b" "a" (nfa.decline))
(declare-const nfa.trans (-> State String State State)) ; state action new_state otherwise
(declare-const nfa.list (-> State State State) :right-assoc-nil nfa.decline)

;(declare-const nfa.str_to_state (-> String State))



(program $get_trans_rec ((r RegLan) (trans State) (start State) (accept State)
                        (s String) (r1 RegLan) (rr RegLan :list) (c0 String) (c1 String))
  (RegLan State State State) State ; regex trans start accept
    (
        (($get_trans_rec (re.opt r1) trans start accept)  ($get_trans_rec (re.union r1 (str.to_re "")) trans start accept))
        
        (($get_trans_rec re.none trans start accept)  trans)

        (($get_trans_rec re.all trans start accept)  ($get_trans_rec (re.* re.allchar) trans start accept))

        (($get_trans_rec re.allchar trans start accept)  (nfa.trans start nfa.allchar accept trans))

        (($get_trans_rec (re.range c0 c1) trans start accept)  (nfa.trans start (nfa.range c0 c1) accept trans))

        (($get_trans_rec (re.++ r1 rr) trans start accept)  (eo::define ((lhs_s (eo::concat start "l")))
                                                            (eo::define ((lhs_a (eo::concat accept "l")))
                                                            (eo::define ((rhs_s (eo::concat start "r")))
                                                            (eo::define ((rhs_a (eo::concat accept "r")))

                                                            (eo::define ((trans1 (nfa.trans start nfa.epsilon lhs_s trans)))
                                                            (eo::define ((trans2 (nfa.trans lhs_a nfa.epsilon rhs_s trans1)))
                                                            (eo::define ((trans3 (nfa.trans rhs_a nfa.epsilon accept trans2)))

                                                            (eo::define ((trans4 ($get_trans_rec r1 trans3 lhs_s lhs_a)))
                                                            ($get_trans_rec rr trans4 rhs_s rhs_a))))))))))

        (($get_trans_rec (re.+ r1) trans start accept)  (eo::define ((lhs_s (eo::concat start "l")))
                                                        (eo::define ((lhs_a (eo::concat accept "l")))

                                                        (eo::define ((trans1 (nfa.trans start nfa.epsilon lhs_s trans)))
                                                        (eo::define ((trans2 (nfa.trans lhs_a nfa.epsilon accept trans1)))
                                                        (eo::define ((trans3 (nfa.trans lhs_a nfa.epsilon lhs_s trans2)))

                                                        (eo::define ((trans4 ($get_trans_rec r1 trans3 lhs_s lhs_a)))
                                                        trans4)))))))

        (($get_trans_rec (re.* r1) trans start accept)  (eo::define ((lhs_s (eo::concat start "l")))
                                                        (eo::define ((lhs_a (eo::concat accept "l")))

                                                        (eo::define ((trans0 (nfa.trans start nfa.epsilon accept trans)))
                                                        (eo::define ((trans1 (nfa.trans start nfa.epsilon lhs_s trans0)))
                                                        (eo::define ((trans2 (nfa.trans lhs_a nfa.epsilon accept trans1)))
                                                        (eo::define ((trans3 (nfa.trans lhs_a nfa.epsilon lhs_s trans2)))

                                                        (eo::define ((trans4 ($get_trans_rec r1 trans3 lhs_s lhs_a)))
                                                        trans4))))))))

        (($get_trans_rec re.none trans start accept)  trans)

        (($get_trans_rec (re.union r1 rr) trans start accept)   (eo::define ((lhs_s (eo::concat start "l")))
                                                                (eo::define ((lhs_a (eo::concat accept "l")))
                                                                (eo::define ((rhs_s (eo::concat start "r")))
                                                                (eo::define ((rhs_a (eo::concat accept "r")))

                                                                (eo::define ((trans0 (nfa.trans start nfa.epsilon lhs_s trans)))
                                                                (eo::define ((trans1 (nfa.trans lhs_a nfa.epsilon accept trans0)))
                                                                (eo::define ((trans2 (nfa.trans start nfa.epsilon rhs_s trans1)))
                                                                (eo::define ((trans3 (nfa.trans rhs_a nfa.epsilon accept trans2)))

                                                                (eo::define ((trans4 ($get_trans_rec r1 trans3 lhs_s lhs_a)))
                                                                (eo::define ((trans5 ($get_trans_rec rr trans4 rhs_s rhs_a)))
                                                                trans5)))))))))))
        
        (($get_trans_rec (str.to_re s) trans start accept)  (eo::define ((lhs_s (eo::concat start "l")))
                                                            (eo::define ((char (eo::extract s 0 0)))
                                                            (eo::define ((s1 (eo::extract s 1 (eo::len s))))

                                                            (eo::define ((trans0 (nfa.trans start (eo::ite (eo::is_eq char "") nfa.epsilon char) lhs_s trans)))

                                                            (eo::define ((trans1 (eo::ite (eo::is_eq s1 "") (nfa.trans lhs_s nfa.epsilon accept trans0) ($get_trans_rec (str.to_re s1) trans0 lhs_s accept))))
                                                            trans1))))))
    )
)

(program $is_state_in_list  ((state State) (states State :list)
                            (state0 State))
  (State State) Bool ; state states
  (
    (($is_state_in_list state (nfa.list state states))    true)
    (($is_state_in_list state nfa.decline)   false)
    (($is_state_in_list state (nfa.list state0 nfa.decline))   false)
    (($is_state_in_list state (nfa.list state0 states))   ($is_state_in_list state states))  )
)

(program $add_state ((states State :list) (new_state State) (visited State))
  (State State State) State ; state states visited -> states
  (
    (($add_state new_state states visited) (eo::ite (eo::or ($is_state_in_list new_state states) ($is_state_in_list new_state visited))  states (nfa.list new_state states)))
  )
)

(program $get_next_states   ((state State) (c String) (trans State) (states State) (visited State)
                            (next State) (state0 State) (state1 State) (state2 State) (c0 String) (c1 String) (c2 String))
  (State String State State State) State ; <current_state> <char> <trans> <visited> <states> -> state_list
  (
    (($get_next_states state c nfa.decline visited states) states)

    (($get_next_states state c (nfa.trans state c next trans) visited states) ($get_next_states state c trans visited ($add_state next states visited)))

    (($get_next_states state nfa.epsilon (nfa.trans state0 c0 next trans) visited states) ($get_next_states state nfa.epsilon trans visited states))

    (($get_next_states state c (nfa.trans state nfa.allchar next trans) visited states) ($get_next_states state c trans visited ($add_state next states visited)))

    (($get_next_states state c (nfa.trans state (nfa.range c0 c1) next trans) visited states) ($get_next_states state c trans visited
                                                                                        (eo::ite (eo::is_eq c nfa.epsilon) states (eo::ite (eo::and ($compare_geq (eo::to_z c) (eo::to_z c0)) ($compare_geq (eo::to_z c1) (eo::to_z c))) ($add_state next states visited) states))))

    (($get_next_states state c (nfa.trans state0 c0 next trans) visited states) ($get_next_states state c trans visited states))
  )
)


(program $match ((c String) (s String) (states State :list) (nexts State :list) (trans State)
                (state0 State))
  (String String State State State) State ; current_char rest_string current_states next_states transitions -> end_states
  (
    (($match nfa.epsilon "" nfa.decline nexts trans) nexts)
    (($match nfa.epsilon s nfa.decline nexts trans) ($match (eo::extract s 0 0) (eo::extract s 1 (eo::len s)) nexts nfa.decline trans))
    (($match c s nfa.decline nexts trans) ($match nfa.epsilon s nexts nfa.decline trans))
    (($match nfa.epsilon s (nfa.list state0 states) nexts trans) ($match nfa.epsilon s ($get_next_states state0 nfa.epsilon trans nexts states) (nfa.list state0 nexts) trans))
    (($match c s (nfa.list state0 states) nexts trans) ($match c s states ($get_next_states state0 c trans nexts nexts) trans)) ; TODO
  )
)

(program $str_in_nfa ((s String) (trans State))
  (String State) Bool ; string trans -> bool
  (
    ;(($str_in_nfa s trans)  ($match nfa.epsilon s (nfa.list "s") nfa.decline trans))
    (($str_in_nfa s trans)  ($is_state_in_list "a" ($match nfa.epsilon s (nfa.list "s") nfa.decline trans)))
  )
)

(program $str_eval_str_in_re_nfa ((r RegLan) (s String) (r1 RegLan) (rr RegLan :list))
  (String RegLan) Bool
  (
    ;(($str_eval_str_in_re_nfa s r)  ($get_trans_rec r nfa.decline "s" "a"))

    (($str_eval_str_in_re_nfa s (re.inter r1 rr))  (eo::and ($str_eval_str_in_re_nfa s r1) ($str_eval_str_in_re_nfa s rr)))

    (($str_eval_str_in_re_nfa s (re.comp r1))  (eo::not ($str_eval_str_in_re_nfa s r1)))

    (($str_eval_str_in_re_nfa s (re.diff r1 rr))  (eo::and ($str_eval_str_in_re_nfa s r1) (eo::not ($str_eval_str_in_re_nfa s rr))))

    (($str_eval_str_in_re_nfa s r)  ($str_in_nfa s ($get_trans_rec r nfa.decline "s" "a")))
  )
)