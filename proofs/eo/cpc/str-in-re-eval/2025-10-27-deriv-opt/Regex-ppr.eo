; program: $nullable
; args:
; - r RegLan: The regular language to check.
; returns: Bool
;   Whether the regular language r contains the empty string.
(program $nullable ((r RegLan) (rr RegLan :list))
  :signature (RegLan) Bool
  (
    (($nullable re.all)          true)
    (($nullable @re.empty)       true)
    (($nullable (re.* r))        true)
    (($nullable (re.union r rr)) (eo::or ($nullable r) ($nullable rr)))
    (($nullable (re.inter r rr)) (eo::and ($nullable r) ($nullable rr)))
    (($nullable (re.++ r rr))    (eo::and ($nullable r) ($nullable rr)))
    (($nullable (re.comp r))     (eo::not ($nullable r)))
    (($nullable r)               false)
  )
)

; program: $ac_merge
; args:
; - f (-> RegLan RegLan RegLan): The constructor for the Associative and Commutative (AC) operator (re.union, re.inter).
; - r1 RegLan: A regular language term.
; - rr1 RegLan :list: A list of regular language terms for the first argument.
; - r2 RegLan: Another regular language term.
; - rr2 RegLan :list: A list of regular language terms for the second argument.
; returns: RegLan
;   A function to flatten the construction of an AC list regular expression operator.
(program $ac_merge ((f (-> RegLan RegLan RegLan)) (r1 RegLan) (rr1 RegLan :list) (r2 RegLan) (rr2 RegLan :list))
  :signature ((-> RegLan RegLan RegLan) RegLan RegLan) RegLan
  (
    (($ac_merge re.union re.none r1)      r1)
    (($ac_merge re.inter re.none r1)      re.none)
    (($ac_merge f r1 r1)                  r1)
    (($ac_merge f (f r1 rr1) (f r2 rr2))  (eo::list_concat f (eo::list_diff f (f r1 rr1) (f r2 rr2)) (f r2 rr2)))
    (($ac_merge f (f r1 rr1) r2)          (eo::ite (eo::is_neg (eo::list_find f (f r1 rr1) r2)) (eo::cons f r2 (f r1 rr1)) (f r1 rr1)))
    (($ac_merge f r2 (f r1 rr1))          (eo::ite (eo::is_neg (eo::list_find f (f r1 rr1) r2)) (eo::cons f r2 (f r1 rr1)) (f r1 rr1)))
    (($ac_merge f r1 r2)                  (f r1 (f r2 (eo::nil f RegLan))))
  )
)

; program: $concat_merge
; args:
; - r1 RegLan: The first term of the concatenation.
; - rr1 RegLan :list: The list of remaining terms in the first concatenation.
; - r2 RegLan: The second term of the concatenation.
; - rr2 RegLan :list: The list of remaining terms in the second concatenation.
; returns: RegLan
;   A function to flatten the concatenation (re.++) of two regular expressions.
(program $concat_merge ((r1 RegLan) (rr1 RegLan :list) (r2 RegLan) (rr2 RegLan :list))
  :signature (RegLan RegLan) RegLan
  (
    (($concat_merge (re.++ r1 rr1) (re.++ r2 rr2))  (eo::list_concat re.++ (re.++ r1 rr1) (re.++ r2 rr2)))
    (($concat_merge re.none r1)                     re.none)
    (($concat_merge r1 (re.++ r2 rr2))              (eo::cons re.++ r1 (re.++ r2 rr2)))
    (($concat_merge @re.empty r1)                   r1)
    (($concat_merge r1 @re.empty)                   r1)
    (($concat_merge r1 r2)                          (re.++ r1 r2))
  )
)

; program: $derivative
; args:
; - c String: The single character to take the derivative with respect to.
; - s1 String: A string argument, used for str.to_re or re.range.
; - s2 String: A string argument, used for re.range.
; - r RegLan: The regular language expression.
; - rr RegLan :list: A list of regular language terms (for re.union/re.inter).
; returns: RegLan
;   Computes the Brzozowski derivative of a regular language with respect to a character c.
(program $derivative ((c String) (s1 String) (s2 String) (r RegLan) (rr RegLan :list))
  :signature (String RegLan) RegLan
  (    
    (($derivative c (re.union r rr))   ($ac_merge re.union ($derivative c r) ($derivative c rr) ))
    (($derivative c (re.++ r rr))      
      (eo::ite ($nullable r) ($ac_merge re.union ($derivative c rr) ($concat_merge ($derivative c r) rr)) ($concat_merge ($derivative c r) rr)))
    (($derivative c (re.inter r rr))   ($ac_merge re.inter ($derivative c r) ($derivative c rr) ))
    (($derivative c (re.comp r))       (re.comp ($derivative c r)))
    (($derivative c (re.* r))          ($concat_merge ($derivative c r) (re.* r)))
    (($derivative c (str.to_re s1))    (eo::ite (eo::is_eq (eo::extract s1 0 0) c) (str.to_re (eo::extract s1 1 (eo::add -1 (eo::len s1)))) re.none))
    (($derivative c (re.range s1 s2))  (eo::ite (eo::and ($compare_geq (eo::to_z c) (eo::to_z s1)) ($compare_geq (eo::to_z s2) (eo::to_z c))) @re.empty re.none))
    (($derivative c re.none)           re.none)
    (($derivative c @re.empty)         re.none)
    (($derivative c re.all)            re.all)
    (($derivative c re.allchar)        @re.empty)
  )
)

; program: $str_eval_str_in_re_deriv
; args:
; - s String: The input string.
; - r RegLan: The regular expression.
; returns: Bool
;   Checks if the string s is accepted by the regular language L(r) using the derivative method.
;   String s is accepted if and only if the derivative is nullable.
(program $str_eval_str_in_re_deriv ((s String) (r RegLan))
  :signature (String RegLan) Bool
  (
    (($str_eval_str_in_re_deriv "" r)       ($nullable r))
    (($str_eval_str_in_re_deriv s re.none)  false)
    (($str_eval_str_in_re_deriv s r)        ($str_eval_str_in_re_deriv (eo::extract s 1 (eo::add -1 (eo::len s))) ($derivative (eo::extract s 0 0) r)))
  )
)
