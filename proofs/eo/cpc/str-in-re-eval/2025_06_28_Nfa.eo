(define nfa.char () String)
(declare-const nfa.allchar nfa.char)
(declare-const nfa.range (-> Int Int nfa.char))
(declare-const nfa.push nfa.char)
(declare-const nfa.pop nfa.char)
(declare-const nfa.none nfa.char)
(declare-type nfa.trans ())
(declare-const nfa.end nfa.trans)
(declare-const nfa.list (-> nfa.trans nfa.trans nfa.trans) :right-assoc-nil nfa.end)
(declare-const nfa.node (-> nfa.char nfa.trans nfa.trans))

(program $get_trans_rec ((tail nfa.trans) (s String) (r1 RegLan) (rr RegLan :list) (c0 String) (c1 String))
  (RegLan nfa.trans) nfa.trans ; regex tail -> new_tail
  (
    (($get_trans_rec (re.* r1) tail) (eo::cons nfa.list (nfa.node nfa.push ($get_trans_rec r1 (nfa.list (nfa.node nfa.pop tail)))) tail))
    (($get_trans_rec re.allchar tail) (nfa.list (nfa.node nfa.allchar tail)))
    (($get_trans_rec re.none tail) (nfa.list (nfa.node nfa.none tail)))
    (($get_trans_rec (re.union r1 rr) tail) (eo::list_concat nfa.list ($get_trans_rec r1 tail) ($get_trans_rec rr tail)))
    (($get_trans_rec (re.++ r1 rr) tail) ($get_trans_rec r1 ($get_trans_rec rr tail)))
    (($get_trans_rec @re.empty tail) tail)
    (($get_trans_rec (re.range c0 c1) tail) (nfa.list (nfa.node (nfa.range (eo::to_z c0) (eo::to_z c1)) tail)))
    (($get_trans_rec (str.to_re s) tail)  (nfa.list (nfa.node (eo::extract s 0 0) ($get_trans_rec (str.to_re (eo::extract s 1 (eo::len s))) tail))))
    (($get_trans_rec re.all tail) ($get_trans_rec (re.* re.allchar) tail))
  )
)

(program $add_to_nexts ((t nfa.trans) (st nfa.trans) (tt nfa.trans :list) (stt nfa.trans :list) (nexts nfa.trans))
  (nfa.trans nfa.trans nfa.trans) nfa.trans ; new stack nexts -> nexts
  (
    (($add_to_nexts nfa.end st nexts) nexts)
    (($add_to_nexts (nfa.list (nfa.node nfa.push t) tt) st nexts) 
      ($add_to_nexts tt st ($add_to_nexts t (eo::cons nfa.list t st) nexts))
      ;(eo::ite (eo::is_neg (eo::list_find nfa.list nexts (nfa.list (nfa.node nfa.push t) st)))
      ; ($add_to_nexts tt st ($add_to_nexts t (eo::cons nfa.list t st) (eo::cons nfa.list (nfa.list (nfa.node nfa.push t) st) nexts)))
      ; ($add_to_nexts tt st nexts)
      ;)
    )
    (($add_to_nexts (nfa.list (nfa.node nfa.pop t) tt) (nfa.list st stt) nexts)
      (eo::ite (eo::is_neg (eo::list_find nfa.list nexts (nfa.list (nfa.node nfa.pop t) (nfa.list st stt))))
        ($add_to_nexts (eo::list_concat nfa.list st tt) (nfa.list st stt) (eo::cons nfa.list (nfa.list (nfa.node nfa.pop t) (nfa.list st stt)) ($add_to_nexts t stt nexts)))
        ($add_to_nexts tt (nfa.list st stt) nexts)
      )
    )
    (($add_to_nexts (nfa.list t tt) st nexts)
      (eo::ite (eo::is_neg (eo::list_find nfa.list nexts (nfa.list t st)))
        ($add_to_nexts tt st (eo::cons nfa.list (nfa.list t st) nexts))
        ($add_to_nexts tt st nexts)
      )
    )
  )
)

(program $match ((c String) (s String) (nexts nfa.trans) (tt nfa.trans :list) (t nfa.trans)
                (st nfa.trans) (z0 Int) (z1 Int))
  (nfa.char String nfa.trans nfa.trans) Bool ; current_char rest_string current_states next_states transitions -> end_states
  (
    (($match c s nfa.end nfa.end) false)
    (($match c "" nfa.end nexts) (eo::not (eo::is_neg (eo::list_find nfa.list nexts (nfa.list nfa.end nfa.end)))))
    (($match "" s t nfa.end) ($match "" s nfa.end ($add_to_nexts t nfa.end nfa.end)))
    (($match c s nfa.end nexts) ($match (eo::extract s 0 0) (eo::extract s 1 (eo::len s)) nexts nfa.end))
    (($match c s (nfa.list (nfa.list (nfa.node c t) st) tt) nexts)  ($match c s tt ($add_to_nexts t st nexts)))
    (($match c s (nfa.list (nfa.list (nfa.node nfa.allchar t) st) tt) nexts)  ($match c s tt ($add_to_nexts t st nexts)))
    (($match c s (nfa.list (nfa.list (nfa.node (nfa.range z0 z1) t) st) tt) nexts)
      (eo::ite (eo::and ($compare_geq (eo::to_z c) z0) ($compare_geq z1 (eo::to_z c)))  
        ($match c s tt ($add_to_nexts t st nexts))
        ($match c s tt nexts))
    )
    (($match c s (nfa.list t tt) nexts)  ($match c s tt nexts))
  )
)

(program $is_extended ((r RegLan) (rr RegLan :list))
  (RegLan) Bool
  (
    (($is_extended (re.union r rr)) (eo::or ($is_extended r) ($is_extended rr)))
    (($is_extended (re.++ r rr)) (eo::or ($is_extended r) ($is_extended rr)))
    (($is_extended (re.* r)) ($is_extended r))
    (($is_extended (re.comp r)) true)
    (($is_extended (re.inter r rr)) true)
    (($is_extended (re.+ r)) ($is_extended r))
    (($is_extended r) false)
  )
)

(program $str_eval_str_in_re_nfa ((r RegLan) (s String))
  :signature (String RegLan) Bool
  (
    (($str_eval_str_in_re_nfa s r)  
      (eo::define ((nfa ($get_trans_rec r (nfa.list nfa.end))))
        (eo::ite (eo::is_ok nfa)
          ($match "" s ($get_trans_rec r (nfa.list nfa.end)) nfa.end)
          ($str_eval_str_in_re s r)
        )
      )
    )
  )
)

