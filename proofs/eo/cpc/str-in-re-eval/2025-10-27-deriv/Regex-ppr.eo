; program: $nullable
; args:
; - r RegLan: The regular language to check.
; returns: Bool
;   True if the regular language r contains the empty string (epsilon, $\epsilon$), false otherwise.
(program $nullable ((r RegLan) (rr RegLan :list))
  :signature (RegLan) Bool
  (
    (($nullable re.all)          true)
    (($nullable @re.empty)       true)
    (($nullable (re.* r))        true)
    (($nullable (re.union r rr)) (eo::or ($nullable r1) ($nullable rr)))
    (($nullable (re.inter r rr)) (eo::and ($nullable r1) ($nullable rr)))
    (($nullable (re.++ r rr))    (eo::and ($nullable r1) ($nullable rr)))
    (($nullable (re.comp r))     (eo::not ($nullable r1)))
    (($nullable r)               false)
  )
)

; program: $ac_merge
; args:
; - t (-> RegLan RegLan): The constructor for the Associative and Commutative (AC) operator (e.g., re.union, re.inter).
; - r1 RegLan: A regular language term.
; - r2 RegLan: Another regular language term.
; - rr1 RegLan :list: A list of regular language terms for the first argument.
; - rr2 RegLan :list: A list of regular language terms for the second argument.
; returns: RegLan
;   A function to **canonicalize** the construction of an AC list-like regular expression operator (like union or intersection). This includes **flattening** nested structures and handling **identity** elements.
(program $ac_merge ((t (-> RegLan RegLan)) (r1 RegLan) (rr1 RegLan :list) (r2 RegLan) (rr2 RegLan :list))
  :signature (Type RegLan RegLan) RegLan
  (
    (($ac_merge re.union re.none r1)      r1)
    (($ac_merge re.inter re.none r1)      re.none)
    (($ac_merge t r1 r1)                  r1)
    (($ac_merge t (t r1 rr1) (t r2 rr2))  (eo::list_concat t (eo::list_diff t (t r1 rr1) (t r2 rr2)) (t r2 rr2)))
    (($ac_merge t (t r1 rr1) r2)          (eo::ite (eo::is_neg (eo::list_find t (t r1 rr1) r2)) (eo::cons t r2 (t r1 rr1)) (t r1 rr1)))
    (($ac_merge t r2 (t r1 rr1) )         (eo::ite (eo::is_neg (eo::list_find t (t r1 rr1) r2)) (eo::cons t r2 (t r1 rr1)) (t r1 rr1)))
    (($ac_merge t r1 r2)                  (t r1 (t r2 (eo::nil t RegLan))))
  )
)

; program: $concat_merge
; args:
; - r1 RegLan: The first term of the concatenation.
; - rr1 RegLan :list: The list of remaining terms in the first concatenation (if r1 is nested).
; - r2 RegLan: The second term of the concatenation.
; - rr2 RegLan :list: The list of remaining terms in the second concatenation (if r2 is nested).
; returns: RegLan
;   A function for **canonicalizing** the **concatenation** (re.++) of two regular expressions, primarily by **flattening** nested concatenations and removing the **empty string** (@re.empty) and **empty set** (re.none) identities.
(program $concat_merge ((r1 RegLan) (rr1 RegLan :list) (r2 RegLan) (rr2 RegLan :list))
  :signature (RegLan RegLan) RegLan
  (
    (($concat_merge (re.++ r1 rr1) (re.++ r2 rr2))  (eo::list_concat re.++ (re.++ r1 rr1) (re.++ r2 rr2)))
    (($concat_merge re.none r1)                      re.none)
    (($concat_merge r1 (re.++ r2 rr2))               (eo::cons re.++ r1 (re.++ r2 rr2)))
    (($concat_merge @re.empty r1)                    r1)
    (($concat_merge r1 @re.empty)                    r1)
    (($concat_merge r1 r2)                           (re.++ r1 r2))
  )
)

; program: $derivative
; args:
; - c String: The single character to take the derivative with respect to.
; - s1 String: A string argument, used for str.to_re or re.range.
; - s2 String: A string argument, used for re.range.
; - r RegLan: The regular language expression.
; - rr RegLan :list: A list of regular language terms (for re.union/re.inter).
; returns: RegLan
;   Computes the **Brzozowski derivative** $D_c(L)$ of a regular language $L$ with respect to a character $c$.
(program $derivative ((c String) (s1 String) (s2 String) (r RegLan) (rr RegLan :list))
  :signature (String RegLan) RegLan
  (    
    (($derivative c (re.union r rr))   ($ac_merge re.union ($derivative c r) ($derivative c rr) ))
    (($derivative c (re.inter r rr))   ($ac_merge re.inter ($derivative c r) ($derivative c rr) ))
    (($derivative c (re.comp r))       (re.comp ($derivative c r)))
    (($derivative c (re.* r))          ($concat_merge ($derivative c r) (re.* r)))
    (($derivative c (str.to_re s1))    (eo::ite (eo::is_eq (eo::extract s1 0 0) c) (str.to_re (eo::extract s1 1 (eo::add -1 (eo::len s1)))) re.none))
    (($derivative c (re.range s1 s2))  (eo::ite (eo::and ($compare_geq (eo::to_z c) (eo::to_z s1)) ($compare_geq (eo::to_z s2) (eo::to_z c))) @re.empty re.none))
    (($derivative c re.none)           re.none)
    (($derivative c @re.empty)         re.none)
    (($derivative c re.all)            re.all)
    (($derivative c re.allchar)        @re.empty)
    (($derivative c (re.++ r rr))      (eo::ite ($nullable r)
                                                 ($ac_merge re.union ($derivative c rr) ($concat_merge ($derivative c r) rr))
                                                 ($concat_merge ($derivative c r) rr)))
  )
)

; program: $str_eval_str_in_re_deriv
; args:
; - s String: The input string.
; - r RegLan: The regular language expression.
; returns: Bool
;   Checks if the string $s$ is accepted by the regular language $L(r)$ using the **derivative method**. String $s$ is accepted if and only if the derivative $D_s(r)$ is nullable.
(program $str_eval_str_in_re_deriv ((s String) (r RegLan))
  :signature (String RegLan) Bool
  (
    (($str_eval_str_in_re_deriv "" r)       ($nullable r))
    (($str_eval_str_in_re_deriv s re.none)  false)
    (($str_eval_str_in_re_deriv s r)        ($str_eval_str_in_re_deriv (eo::extract s 1 (eo::add -1 (eo::len s))) ($derivative (eo::extract s 0 0) r)))
  )
)